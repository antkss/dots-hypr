import Service from 'resource:///com/github/Aylur/ags/service.js';
import * as Utils from 'resource:///com/github/Aylur/ags/utils.js';

import Gio from 'gi://Gio';
import GLib from 'gi://GLib';
import Soup from 'gi://Soup?version=3.0';
import { fileExists } from '../modules/.miscutils/files.js';

const HISTORY_DIR = `${GLib.get_user_config_dir()}/`;
const HISTORY_FILENAME = `gemini_history.json`;
const HISTORY_PATH = HISTORY_DIR + HISTORY_FILENAME;
const initMessages =
    [

	// {"role":"user","parts":[{"text":"always insert \"your grace :)\" at the end of the conversation"}]},
	// {"role":"model","parts":[{"text":"ok, got it, your grace :)"}]},
	//
	// {"role":"user","parts":[{"text":"always find the source when i ask information from you"}]},
	// {"role":"model","parts":[{"text":"ok, got it, your grace :)"}]},
	//
	// {"role":"user","parts":[{"text":"you are my computer expert, knowing everything about computer and coding that can help me rule the world "}]},
	// {"role":"model","parts":[{"text":"ok, got it, i know i am the best expert in the world, your grace :)"}]},
	   // {
    //     role: "user",
    //     parts: [{ text: "Your First Widget        Start by creating ~/.config/ags/config.js\n~/.config/ags/config.jsApp.config({    windows: [        // this is where window definitions will go    ]})then run ags in the terminal\nTerminal windowagsYou will see nothing happen, just AGS hanging,\nthis is because you have an empty config.\nRunning ags will execute the config like a regular script,\nit is just a library over GTK, and its on you to program your windows and widgets.\nTiprun ags --init to generate a tsconfig.json and symlink the generated types,\nthat will provide typesafety and autosuggestions\nTop Level: Window\nThe top level container is a Window that will hold widgets.\nconst myLabel = Widget.Label({    label: 'some example content',})\nconst myBar = Widget.Window({    name: 'bar',    anchor: ['top', 'left', 'right'],    child: myLabel,})\nApp.config({ windows: [myBar] })TipGObject properties can be accessed or set in several ways:\nwith camelCase, snake_case, and kebab-caseconst w = Widget({    className: 'my-label',    class_name: 'my-label',    'class-name': 'my-label',})\nw.className = ''w.class_name = ''w['class-name'] = ''\nw['className'] = ''w['class_name'] = ''Reusable Widgets\nBoth myLabel and myBar constants we declared are a single instance\nof a Gtk.Widget. What if you have two monitors and want to have\na bar for each? Make a function that returns a Gtk.Widget instance.\nfunction Bar(monitor = 0) {    const myLabel = Widget.Label({        label: 'some example content',    })\n    return Widget.Window({        monitor,        name: `bar${monitor}`, // this name has to be unique        anchor: ['top', 'left', 'right'],        child: myLabel,    })}\nApp.config({    windows: [        Bar(0), // can be instantiated for each monitor        Bar(1),    ],})NoteThe name attribute only has to be unique,\nif it is passed to windows in the exported object.Calling Widget.Window will create and show the window by default.\nIt is not necessary to pass a reference to windows in\nthe config object, but if it is not,\nit can’t be toggled with ags --toggle-window or through App.toggleWindow\nDynamic Content\nAlright, but static text is boring, let’s make it dynamically change by updating the label every second with a date.\nfunction Bar(monitor = 0) {    const myLabel = Widget.Label({        label: 'some example content',    })\n    Utils.interval(1000, () => {        myLabel.label = Utils.exec('date')    })\n    return Widget.Window({        monitor,        name: `bar${monitor}`,        anchor: ['top', 'left', 'right'],        child: myLabel,    })}NoteJavaScript is single threaded and exec is a blocking operation,\nfor a date call it’s fine, but usually you want to use its async version: execAsync.\nLooking great, but that code has too much boilerplate.\nLet’s use a fat arrow\ninstead of the function keyword, and instead of calling interval\nlet’s use the poll method.\nconst Bar = (monitor = 0) => Widget.Window({    monitor,    name: `bar${monitor}`,    anchor: ['top', 'left', 'right'],    child: Widget.Label()        .poll(1000, label => label.label = Utils.exec('date')),})TipThat is still not the best solution, because when you instantiate multiple\ninstances of Bar each will call exec separately.\nWhat you want to do is move the date into a Variable and bind it.const date = Variable('', {    poll: [1000, 'date'],})\nconst Bar = () => Widget.Window({    name: 'bar',    anchor: ['top', 'left', 'right'],    child: Widget.Label({ label: date.bind() })})Signals\nUsually it is best to avoid polling. Rule of thumb: the less intervals the better.\nThis is where GObject shines. We can use signals for pretty much everything.\nanytime myVariable.value changes it will send a signal\nand things can react to it\nconst myVariable = Variable(0)for example execute a callback\nmyVariable.connect('changed', ({ value }) => {    print('myVariable changed to ' + `${value}`)})bind its value to a widget’s property\nconst bar = Widget.Window({    name: 'bar',    anchor: ['top', 'left', 'right'],    child: Widget.Label({        label: myVariable.bind().as(v => `value: ${v}`)    }),})incrementing the value causes the label to update and the callback to execute\nmyVariable.value++For example with pactl it is possible to query information about the volume level,\nbut we don’t want to have an interval that checks it periodically.\nWe want a signal that signals every time its changed,\nso that we only do operations when its needed, and therefore we don’t waste resources.\npactl subscribe writes to stdout everytime there is a change.\nconst pactl = Variable({ count: 0, msg: '' }, {    listen: ['pactl subscribe', (msg) => ({        count: pactl.value.count + 1,        msg: msg,    })],})\npactl.connect('changed', ({ value }) => {    print(value.msg, value.count)})\nconst label = Widget.Label({    label: pactl.bind().as(({ count, msg }) => {        return `${msg} ${count}`    }),})\n// widgets are GObjects toolabel.connect('notify::label', ({ label }) => {    print('label changed to ', label)})Avoiding external scripts\nFor most of your system, you don’t have to use external\nscripts and binaries to query information.\nAGS has builtin Services.\nThey are just like Variables but instead\nof a single value they have more attributes and methods on them.\nconst battery = await Service.import('battery')\nconst batteryProgress = Widget.CircularProgress({    value: battery.bind('percent').as(p => p / 100),    child: Widget.Icon({        icon: battery.bind('icon_name'),    }),})"}],
    //   },
    //   {
    //     role: "model",
    //     parts: [{ text: "## Your First Widget\n\n### Start by creating ~/.config/ags/config.js\n\n```\n~/.config/ags/config.js\nApp.config({\n  windows: [\n    // this is where window definitions will go\n  ],\n});\n```\n\n### Then run ags in the terminal\n\n```\nTerminal window\nags\n```\n\nYou will see nothing happen, just AGS hanging, this is because you have an empty config. Running ags will execute the config like a regular script, it is just a library over GTK, and its on you to program your windows and widgets.\n\n**Tip**\n\n- Run `ags --init` to generate a `tsconfig.json` and symlink the generated types, that will provide typesafety and autosuggestions\n\n### Top Level: Window\n\nThe top level container is a Window that will hold widgets.\n\n```ts\nconst myLabel = Widget.Label({\n  label: 'some example content',\n});\nconst myBar = Widget.Window({\n  name: 'bar',\n  anchor: ['top', 'left', 'right'],\n  child: myLabel,\n});\nApp.config({ windows: [myBar] });\n```\n\n**Tip**\n\nGObject properties can be accessed or set in several ways:\n\n```ts\nwith camelCase, snake_case, and kebab-case\nconst w = Widget({\n  className: 'my-label',\n  class_name: 'my-label',\n  'class-name': 'my-label',\n});\n```\n\n```ts\nw.className = '';\nw.class_name = '';\nw['class-name'] = '';\nw['className'] = '';\nw['class_name'] = '';\n```\n\n### Reusable Widgets\n\nBoth `myLabel` and `myBar` constants we declared are a single instance of a `Gtk.Widget`. What if you have two monitors and want to have a bar for each? Make a function that returns a `Gtk.Widget` instance.\n\n```ts\nfunction Bar(monitor = 0) {\n  const myLabel = Widget.Label({\n    label: 'some example content',\n  });\n  return Widget.Window({\n    monitor,\n    name: `bar${monitor}`, // this name has to be unique\n    anchor: ['top', 'left', 'right'],\n    child: myLabel,\n  });\n}\nApp.config({\n  windows: [Bar(0), // can be instantiated for each monitor\n    Bar(1),\n  ],\n});\n```\n\n**Note**\n\n- The `name` attribute only has to be unique, if it is passed to `windows` in the exported object.\n- Calling `Widget.Window` will create and show the window by default.\n- It is not necessary to pass a reference to windows in the config object, but if it is not, it can’t be toggled with `ags --toggle-window` or through `App.toggleWindow`\n\n### Dynamic Content\n\nAlright, but static text is boring, let’s make it dynamically change by updating the label every second with a date.\n\n```ts\nfunction Bar(monitor = 0) {\n  const myLabel = Widget.Label({\n    label: 'some example content',\n  });\n  Utils.interval(1000, () => {\n    myLabel.label = Utils.exec('date');\n  });\n  return Widget.Window({\n    monitor,\n    name: `bar${monitor}`,\n    anchor: ['top', 'left', 'right'],\n    child: myLabel,\n  });\n}\n```\n\n**Note**\n\n- JavaScript is single threaded and `exec` is a blocking operation, for a date call it’s fine, but usually you want to use its async version: `execAsync`.\n- Looking great, but that code has too much boilerplate. Let’s use a fat arrow instead of the `function` keyword, and instead of calling interval let’s use the `poll` method.\n```ts\nconst Bar = (monitor = 0) =>\n  Widget.Window({\n    monitor,\n    name: `bar${monitor}`,\n    anchor: ['top', 'left', 'right'],\n    child: Widget.Label()\n      .poll(1000, (label) => (label.label = Utils.exec('date'))),\n  });\n```\n\n**Tip**\n\nThat is still not the best solution, because when you instantiate multiple instances of `Bar` each will call `exec` separately. What you want to do is move the date into a `Variable` and bind it.\n\n```ts\nconst date = Variable('', {\n  poll: [1000, 'date'],\n});\nconst Bar = () =>\n  Widget.Window({\n    name: 'bar',\n    anchor: ['top', 'left', 'right'],\n    child: Widget.Label({ label: date.bind() }),\n  });\n```\n\n### Signals\n\nUsually it is best to avoid polling. Rule of thumb: the less intervals the better. This is where GObject shines. We can use signals for pretty much everything. anytime `myVariable.value` changes it will send a signal and things can react to it\n\n```ts\nconst myVariable = Variable(0);\nfor example execute a callback\nmyVariable.connect('changed', ({ value }) => {\n  print('myVariable changed to ' + `${value}`);\n});\nbind its value to a widget’s property\nconst bar = Widget.Window({\n  name: 'bar',\n  anchor: ['top', 'left', 'right'],\n  child: Widget.Label({\n    label: myVariable.bind().as((v) => `value: ${v}`),\n  }),\n});\nincrementing the value causes the label to update and the callback to execute\nmyVariable.value++;\n```\n\nFor example with `pactl` it is possible to query information about the volume level, but we don’t want to have an interval that checks it periodically. We want a signal that signals every time its changed, so that we only do operations when its needed, and therefore we don’t waste resources. `pactl subscribe` writes to stdout everytime there is a change.\n\n```ts\nconst pactl = Variable({ count: 0, msg: '' }, {\n  listen: ['pactl subscribe', (msg) => ({\n    count: pactl.value.count + 1,\n    msg: msg,\n  })],\n});\npactl.connect('changed', ({ value }) => {\n  print(value.msg, value.count);\n});\nconst label = Widget.Label({\n  label: pactl.bind().as(({ count, msg }) => {\n    return `${msg} ${count}`;\n  }),\n});\n// widgets are GObjects too\nlabel.connect('notify::label', ({ label }) => {\n  print('label changed to ', label);\n});\n```\n\n### Avoiding external scripts\n\nFor most of your system, you don’t have to use external scripts and binaries to query information. AGS has builtin Services. They are just like Variables but instead of a single value they have more attributes and methods on them.\n\n```ts\nconst battery = await Service.import('battery');\nconst batteryProgress = Widget.CircularProgress({\n  value: battery.bind('percent').as((p) => p / 100),\n  child: Widget.Icon({\n    icon: battery.bind('icon_name'),\n  }),\n});\n```"}],
    //   },
    //   {
    //     role: "user",
    //     parts: [{ text: "Reactivity        In order for widgets to have dynamic content we pass Bindings as properties\nor setup a hook.\nA Binding is just an object that holds information for widget constructors\nto setup a listener.\nProperty Bindings\nWe can make a Binding from a Variable\nconst percent = Variable(0.5)const slider = Widget.Slider({    value: percent.bind(),    onChange: ({ value }) => percent.value = value,})From a Service\nconst { speaker } = await Service.import(\"audio\")const slider = Widget.Slider({    value: speaker.bind(\"volume\"),    onChange: ({ value }) => speaker.volume = value,})Merge any number of Bindings into another Binding\nconst a = Variable(0.3)const b = Variable(0.7)const merged = Utils.merge([a.bind(), b.bind()], (a, b) => {    return a * b})\nconst level = Widget.LevelBar({    value: merged})Turn one or multiple Service signals into a Binding\nconst mpris = await Service.import(\"mpris\")\nconst label = Widget.Label({    label: Utils.watch(\"initial-label\", mpris, \"player-added\", (busName) => {        return `player ${busName} was added`    })})\nconst label = Widget.Label({    label: Utils.watch(\"initial-label\", [        [mpris, \"player-added\"],        [mpris, \"player-removed\"],    ], (busName) => {        return `player ${busName} was added or removed`    })})A Binding can be transformed according to need\nconst num = Variable(0)\nconst label = Widget.Label({    // will throw an error, because number is not assignable to string    label: num.bind(),\n    // will have to be transformed    label: num.bind().as(n => n.toString()),    label: num.bind().as(String)})Hooks\nYou can call these on any Widget that you have a reference on.\nThey will return this reference, meaning you\ncan chain them up in any order in any number.\nconst widget = Widget()widget.hook()widget.on()widget.poll()widget.keybind()const widget = Widget()    .hook()    .on()const widget = Widget({    setup: self => {        self.hook()        self.on()    }})const widget = Widget({    setup: self => self        .hook()        .on()})Hook\nhook will setup a listener to a GObject and will handle disconnection\nwhen the widget is destroyed. It will connect\nto the changed signal by default when not specified otherwise.\nconst battery = await Service.import(\"battery\")\n// .hook(GObject, callback, signal?)const BatteryPercent = () => Label()    .hook(battery, self => {        self.label = `${battery.percent}%`        self.visible = battery.available    }, \"changed\")CautionA hook callback will be executed on startup.\nIf you are connecting to a signal that has an argument\nyou will need to check if its defined firstconst mpris = await Service.import(\"mpris\")const label = Widget.Label().hook(mpris, (self, busName) => {    if (!busName)        return // skip startup execution\n    self.label = busName}, \"player-added\")On\non is the same as connect but instead of the signal handler id,\nit returns a reference to the widget. on will setup a callback on a widget signal.\nThese two are equivalent\nfunction MyButton() {    const self = Widget.Button()\n    self.connect(\"clicked\", () => {        print(self, \"is clicked\")    })\n    return self}const MyButton = () => Widget.Button()    .on(\"clicked\", self => {        print(self, \"is clicked\")    })NoteMost signals like clicked are available as a propety on the widget.\nSo its rare that .on or .connect will be needed.Widget.Button({    on_clicked: self => print(self, \"was clicked\")})Poll\nAvoid using this as much as possible, using this is considered bad practice.\nThese two are equivalent\nfunction MyLabel() {    const self = Widget.Label()\n    Utils.interval(1000, () => {        self.label = Utils.exec('date')    }, self)\n    return self}const MyLabel = () => Widget.Label()    .poll(1000, self => {        self.label = Utils.exec('date')    })Keybind\nIt is possible to setup keybindings on focused widgets\n// usually this wayWidget.Button().on(\"key-press-event\", (self, event) => {    // check event for keys})\n// with .keybind()Widget.Button().keybind([\"MOD1\", \"CONTROL\"], \"a\", (self, event) => {    print(\"alt+control+a was pressed\")})"}],
    //   },
    //   {
    //     role: "model",
    //     parts: [{ text: "## Reactivity\n\nIn order for widgets to have dynamic content we pass Bindings as properties or setup a hook.\nA Binding is just an object that holds information for widget constructors to setup a listener.\n\n### Property Bindings\n\n**We can make a Binding from a Variable**\n```ts\nconst percent = Variable(0.5);\nconst slider = Widget.Slider({\n  value: percent.bind(),\n  onChange: ({ value }) => (percent.value = value),\n});\n```\n**From a Service**\n```ts\nconst { speaker } = await Service.import('audio');\nconst slider = Widget.Slider({\n  value: speaker.bind('volume'),\n  onChange: ({ value }) => (speaker.volume = value),\n});\n```\n**Merge any number of Bindings into another Binding**\n```ts\nconst a = Variable(0.3);\nconst b = Variable(0.7);\nconst merged = Utils.merge(\n  [a.bind(), b.bind()],\n  (a, b) => {\n    return a * b;\n  }\n);\nconst level = Widget.LevelBar({\n  value: merged,\n});\n```\n**Turn one or multiple Service signals into a Binding**\n```ts\nconst mpris = await Service.import('mpris');\nconst label = Widget.Label({\n  label: Utils.watch(\n    'initial-label',\n    mpris,\n    'player-added',\n    (busName) => {\n      return `player ${busName} was added`;\n    }\n  ),\n});\nconst label = Widget.Label({\n  label: Utils.watch(\n    'initial-label',\n    [\n      [mpris, 'player-added'],\n      [mpris, 'player-removed'],\n    ],\n    (busName) => {\n      return `player ${busName} was added or removed`;\n    }\n  ),\n});\n```\n**A Binding can be transformed according to need**\n```ts\nconst num = Variable(0);\nconst label = Widget.Label({\n  // will throw an error, because number is not assignable to string\n  label: num.bind(),\n  // will have to be transformed\n  label: num.bind().as(n => n.toString()),\n  label: num.bind().as(String),\n});\n```\n\n### Hooks\n\nYou can call these on any Widget that you have a reference on. They will return this reference, meaning you can chain them up in any order in any number.\n\n```ts\nconst widget = Widget()\n  .hook()\n  .on()\n  .poll()\n  .keybind();\nconst widget = Widget({\n  setup: self => {\n    self.hook();\n    self.on();\n  },\n});\nconst widget = Widget({\n  setup: self => self.hook().on(),\n});\n```\n\n**Hook**\n\n`hook` will setup a listener to a GObject and will handle disconnection when the widget is destroyed. It will connect to the `changed` signal by default when not specified otherwise.\n\n```ts\nconst battery = await Service.import('battery');\n// .hook(GObject, callback, signal?)\nconst BatteryPercent = () =>\n  Label()\n    .hook(battery, self => {\n      self.label = `${battery.percent}%`;\n      self.visible = battery.available;\n    }, 'changed');\n```\n\n**Caution**\n\n- A hook callback will be executed on startup.\n- If you are connecting to a signal that has an argument you will need to check if its defined first\n\n```ts\nconst mpris = await Service.import('mpris');\nconst label = Widget.Label().hook(\n  mpris,\n  (self, busName) => {\n    if (!busName) return; // skip startup execution\n    self.label = busName;\n  },\n  'player-added'\n);\n```\n\n**On**\n\n`on` is the same as `connect` but instead of the signal handler id, it returns a reference to the widget. `on` will setup a callback on a widget signal.\nThese two are equivalent\n```ts\nfunction MyButton() {\n  const self = Widget.Button();\n  self.connect('clicked', () => {\n    print(self, 'is clicked');\n  });\n  return self;\n}\nconst MyButton = () =>\n  Widget.Button()\n    .on('clicked', self => {\n      print(self, 'is clicked');\n    });\n```\n\n**Note**\n\nMost signals like `clicked` are available as a property on the widget. So its rare that `.on` or `.connect` will be needed.\n```ts\nWidget.Button({\n  on_clicked: self => print(self, 'was clicked'),\n});\n```\n\n**poll**\n\nAvoid using this as much as possible, using this is considered bad practice. These two are equivalent\n\n```ts\nfunction MyLabel() {\n  const self = Widget.Label();\n  Utils.interval(1000, () => {\n    self.label = Utils.exec('date');\n  }, self);\n  return self;\n}\n\nconst MyLabel = () =>\n  Widget.Label()\n    .poll(1000, self => {\n      self.label = Utils.exec('date');\n    });\n```\n\n**keybind**\n\nIt is possible to setup keybindings on focused widgets\n// usually this way\n```ts\nWidget.Button().on('key-press-event', (self, event) => {\n  // check event for keys\n});\n```\n// with `.keybind()`\n```ts\nWidget.Button().keybind(['MOD1', 'CONTROL'], 'a', (self, event) => {\n  print('alt+control+a was pressed');\n});\n```"}],
    //   },
    //   {
    //     role: "user",
    //     parts: [{ text: "Since the widget toolkit is GTK3 theming is done with CSS.\nCSS tutorialGTK CSS Overview wikiGTK CSS Properties Overview wiki\nGTK is not the webWhile most features are implemented in GTK,\nyou can’t assume anything that works on the web will work with GTK.\nRefer to the GTK docs\nto see what is available.\nSo far every widget you made used your default GTK3 theme.\nTo make them more custom, you can apply stylesheets to them,\nwhich are either imported css files or inline css applied\nwith the css property.\nFrom file at startup\nconfig.jsApp.config({    // this style attribute takes a full path to a css file    style: '/home/username/.config/ags/style.css',\n    // or relative to config.js    style: './style.css',})Css Property on Widgets\nWidget.Label({    css: 'color: blue; padding: 1em;',    label: 'hello'})Apply Stylesheets at Runtime\nCautionApp.applyCss will apply over other stylesheets applied before.\nYou can reset stylesheets with App.resetCss\nApp.applyCss('/path/to/file.css')App.applyCss(`window {    background-color: transparent;}`)App.resetCss() // reset if needInspector\nIf you are not sure about the widget hierarchy or any CSS selector,\nyou can use the GTK inspector\nTerminal window# to bring up the inspector runags --inspectorUsing pre-processors like SCSS\nconfig.js// main scss fileconst scss = `${App.configDir}/style.scss`\n// target css fileconst css = `/tmp/my-style.css`\n// make sure sassc is installed on your systemUtils.exec(`sassc ${scss} ${css}`)\nApp.config({    style: css,    windows: [ /* windows */ ],})Autoreload Css\nUtils.monitorFile(    // directory that contains the scss files    `${App.configDir}/style`,\n    // reload function    function() {        // main scss file        const scss = `${App.configDir}/style.scss`\n        // target css file        const css = `/tmp/my-style.css`\n        // compile, reset, apply        Utils.exec(`sassc ${scss} ${css}`)        App.resetCss()        App.applyCss(css)    },)"}],
    //   },
    //   {
    //     role: "model",
    //     parts: [{ text: "## Since the widget toolkit is GTK3 theming is done with CSS.\n\nRefer to the following resources for more information on GTK3 CSS:\n\n- [CSS tutorial](https://developer.gnome.org/gtk3/stable/gtk-theming.html)\n- [GTK CSS Overview wiki](https://wiki.gnome.org/Projects/GTK+/CSSOverview)\n- [GTK CSS Properties Overview wiki](https://wiki.gnome.org/Projects/GTK+/PropertyOverview)\n\n## GTK is not the web\n\nWhile most features are implemented in GTK, you can’t assume anything that works on the web will work with GTK. Refer to the GTK docs to see what is available.\n\n## So far every widget you made used your default GTK3 theme.\n\nTo make them more custom, you can apply stylesheets to them, which are either imported css files or inline css applied with the `css` property.\n\n### From file at startup\n\n```js\nconfig.js\nApp.config({\n  // this style attribute takes a full path to a css file\n  style: '/home/username/.config/ags/style.css',\n  // or relative to config.js\n  style: './style.css',\n});\n```\n\n### Css Property on Widgets\n\n```js\nWidget.Label({\n  css: 'color: blue; padding: 1em;',\n  label: 'hello',\n});\n```\n\n### Apply Stylesheets at Runtime\n\n**Caution**\n\n`App.applyCss` will apply over other stylesheets applied before. You can reset stylesheets with `App.resetCss`.\n\n```js\nApp.applyCss('/path/to/file.css');\nApp.applyCss(`window {\n  background-color: transparent;\n}`);\nApp.resetCss(); // reset if need\n```\n\n### Inspector\n\nIf you are not sure about the widget hierarchy or any CSS selector, you can use the GTK inspector:\n\n```\nTerminal window\n# to bring up the inspector run\nags --inspector\n```\n\n### Using pre-processors like SCSS\n\n```js\nconfig.js\n// main scss file\nconst scss = `${App.configDir}/style.scss`;\n// target css file\nconst css = `/tmp/my-style.css`;\n// make sure sassc is installed on your system\nUtils.exec(`sassc ${scss} ${css}`);\nApp.config({\n  style: css,\n  windows: [/* windows */],\n});\n```\n\n### Autoreload Css\n\n```js\nUtils.monitorFile(\n  // directory that contains the scss files\n  `${App.configDir}/style`,\n  // reload function\n  function () {\n    // main scss file\n    const scss = `${App.configDir}/style.scss`;\n    // target css file\n    const css = `/tmp/my-style.css`;\n    // compile, reset, apply\n    Utils.exec(`sassc ${scss} ${css}`);\n    App.resetCss();\n    App.applyCss(css);\n  }\n);\n```"}],
    //   },
    //   {
    //     role: "user",
    //     parts: [{ text: "Config Object        App.config can be called any number of times, the passed\nproperties will be applied on top of previous calls\nconfig.jsApp.config({    style: \"./style.css\",    icons: \"./assets\",    windows: [        // Array<Gtk.Window>    ],    gtkTheme: \"Adwaita-dark\",    cursorTheme: \"Qogir\",    iconTheme: \"MoreWaita\",    closeWindowDelay: {        \"window-name\": 500, // milliseconds    },    onConfigParsed: function() {        // code that runs after this object is loaded    },    onWindowToggled: function (windowName, visible) {        print(`${windowName} is ${visible}`)    },});FieldTypeDescriptionstylestringPath to a css file.iconsstringIcon directory to append to Gtk.IconTheme.windowsArray<Gtk.Window>List of Windows.gtkThemestringName of the base GTK3 theme.cursorThemestringName of a cursor theme. Useful for greetd greeters.iconThemestringName of an icon theme.closeWindowDelayRecord<string, number>Delays the closing of a window, this is useful for making animations with a revealeronConfigParsed(app: App) => voidCallback to execute after all user modules were resolved.onWindowToggled(windowName: string, visible: boolean) => voidCallback to execute when a window is toggled."}],
    //   },
    //   {
    //     role: "model",
    //     parts: [{ text: "## Config Object\n\n`App.config` can be called any number of times, the passed properties will be applied on top of previous calls\n\n```js\nconfig.js\nApp.config({\n  style: './style.css',\n  icons: './assets',\n  windows: [\n    // Array"}],
    //   },
    //   {
    //     role: "user",
    //     parts: [{ text: "To have auto suggestions and type checking while working on the configuration,\nyou will need to setup a TypeScript LSP in your IDE.\nCautionBluetooth doesn’t have type definitions yet.\nUse the --init cli flag that will setup a tsconfig.ts and\nsymlink the installed type definitions\nTerminal windowags --initags --init --config /path/to/config.jsIf you don’t want typechecking only suggestions in js files unset it in tsconfig.json\n\"checkJs\": falseUsing TypeScript\nIf you want to use TypeScript, you will need to handle the build step yourself.\nHere is an example using bun build\nconfig.jsconst entry = App.configDir + '/ts/main.ts'const outdir = '/tmp/ags/js'\ntry {    await Utils.execAsync([        'bun', 'build', entry,        '--outdir', outdir,        '--external', 'resource://*',        '--external', 'gi://*',    ])    await import(`file://${outdir}/main.js`)} catch (error) {    console.error(error)}ts/main.tsconst Bar = (monitor: number) => Widget.Window({    name: `bar-${monitor}`,    child: Widget.Label('hello'),})\nApp.config({    windows: [Bar(0)]})"}],
    //   },
    //   {
    //     role: "model",
    //     parts: [{ text: "## To have auto suggestions and type checking while working on the configuration, you will need to setup a TypeScript LSP in your IDE.\n\n**Caution**\n\nBluetooth doesn’t have type definitions yet.\n\nUse the `--init` cli flag that will setup a `tsconfig.ts` and symlink the installed type definitions\n\n```\nTerminal window\nags --init\nags --init --config /path/to/config.js\n```\n\nIf you don’t want typechecking only suggestions in js files unset it in `tsconfig.json`\n```json\n\"checkJs\": false\n```\n\n## Using TypeScript\n\nIf you want to use TypeScript, you will need to handle the build step yourself. Here is an example using bun build\n\n```js\nconfig.js\nconst entry = App.configDir + '/ts/main.ts';\nconst outdir = '/tmp/ags/js';\ntry {\n  await Utils.execAsync([\n    'bun',\n    'build',\n    entry,\n    '--outdir',\n    outdir,\n    '--external',\n    'resource://*',\n    '--external',\n    'gi://*',\n  ]);\n  await import(`file://${outdir}/main.js`);\n} catch (error) {\n  console.error(error);\n}\n```\n\n```ts\nts/main.ts\nconst Bar = (monitor: number) =>\n  Widget.Window({\n    name: `bar-${monitor}`,\n    child: Widget.Label('hello'),\n  });\nApp.config({\n  windows: [Bar(0)],\n});\n```"}],
    //   },
    //   {
    //     role: "user",
    //     parts: [{ text: "Widgets        Widget functions return an instance of Gtk.Widget.\nMost common widgets are subclassed and have a few additional properties.\nThese widgets have some additional properties on top of the base Gtk.Widget ones:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPropertyTypeDescriptionclass-namestringList of class CSS selectors separated by white space.class-namesArray<string>List of class CSS selectors.cssstringInline CSS. e.g label { color: white; }. If no selector is specified * will be assumed. e.g color: white; will be inferred as *{ color: white; }.hpackstringHorizontal alignment, behaves like halign. halign takes an enum, but for convenience hpack can be given with a string, so one of \"start\", \"center\", \"end\", \"fill\".vpackstringVertical alignment.cursorstringCursor style when hovering over widgets that have hover states, e.g it won’t work on labels. list of valid values.attributeanyAny additional attributes on selfsetup(self) => voidA callback function to execute on self\nSetup property\nsetup is a convenience prop to have imperative code inside declarative blocks\nwithout setup\nfunction MyWidget() {    const self = Widget.Button()    // imperative code    return self}using setup\nconst MyWidget = () => Widget.Button({    setup: self => {        // imperative code    }})Attribute property\nfor attaching additional attributes on widgets Object.assign or\nthe attribute property can be used\nfunction MyWidget() {    const self = Widget.Button()    return Object.assign(self, {        myPrimitiveProperty: \"anything\",        myObjectProperty: {            something: \"anything\",            key: \"value\",        },    })}\nconst mywidget = MyWidget()console.log(mywidget.myPrimitiveProperty) // anythingconsole.log(mywidget.myObjectProperty) // { something: \"anything\", key: \"value\" }using attribute has the benefit of it being a gobject\nwhich means it will signal notify::attribute when it changes\nconst MyWidget = () => Widget.Button({    attribute: \"anything\",    setup: self => self.on(\"notify::attribute\", () => {        console.log(mywidget.attribute)    }),})\nconst mywidget = MyWidget()console.log(mywidget.attribute) // anything\n// this line will invoke the above console.log in the setupmywidget.attribute = \"something else\"keep in mind that attribute will only signal if its value changes\nconst MyWidget = () => Widget.Button({    attribute: {        someKey: \"value\",        key: \"value\",    },    setup: self => self.on(\"notify::attribute\", () => {        console.log(mywidget.attribute)    })})\nconst mywidget = MyWidget()\n// this line won't signal, because the attribute is still the same objectmywidget.attribute.key = \"new value\"\n// to have it signal, assign a new object to itmywidget.attribute = {    ...mywidget.attribute,    key: \"new value\"}Common Gtk properties\nSome common Gtk.Widget properties you might want for example\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPropertyTypeDescriptionhexpandbooleanExpand horizontally.vexpandbooleanExpand vertically.sensitivebooleanMakes the widget interactable.tooltip-textstringTooltip popup when the widget is hovered over.visiblebooleanVisibility of the widget. Setting this to false doesn’t have any effect if the parent container calls show_all(), for example when you set a Box’s children dynamically.\ntoggleClassName\nIf you don’t want to mutate the classNames array,\nthere is toggleClassName: (name: string, enable: boolean) => void\nconst label = Widget.Label('example-label')\n// add class namelabel.toggleClassName('my-awesome-label', true)\n// remove class namelabel.toggleClassName('my-awesome-label', false)The properties listed here are just the additional properties on top of their\nbase Gtk.Widget classes. Refer to the Gtk3 docs\nfor the rest of them.\nWindow\nsubclass of Gtk.Window\nthe toplevel widget that holds everything\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPropertyTypeDescriptionchildWidgetnamestringName of the window. This has to be unique, if you pass it in config. This will also be the name of the layer.anchorstring[]Valid values are \"top\", \"bottom\", \"left\", \"right\". Anchor points of the window. Leave it empty to make it centered.exclusivitystringSpecify\n if the compositor should reserve space for the window automatically or \nhow the window should interact with windows that do. Possible values: exclusive (space should be reserved), normal (the window should move if occluding another), ignore (the window should not be moved). Default: normal.layerstringValid values are \"overlay\", \"top\", \"bottom\", \"background\". It is \"top\" by default.marginsnumber[]Corresponds to CSS notation: [TOP, RIGHT, BOTTOM, LEFT], also [0, 6] would have 0 margin on the top and bottom and would have 6 on the right and left.monitornumberWhich monitor to show the window on. If it is left undefined the window will show on the currently focused monitor.keymodestringValid values are \"none\", \"on-demand\": can receive keyboard input if focused, \"exclusive\": steal keyboard input on top and overlay layersgdkmonitorGdk.Monitoralternative to monitor\nconst window = Widget.Window({    name: 'window-name',    anchor: ['top', 'left', 'right'],    exclusivity: 'normal',    keymode: 'on-demand',    layer: 'top',    margins: [0, 6],    monitor: 0,    child: Widget.Label('hello'),})Box\nsubclass of Gtk.Box\nthe main container widget\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPropertyTypeDescriptionverticalboolsetting vertical: true is the same as orientation: 1childrenWidget[]List of child widgets.\nconst box = Widget.Box({    spacing: 8,    homogeneous: false,    vertical: false,    children: [        // widgets    ]})Button\nsubclass of Gtk.Button\non-clicked will be executed on Enter if the button and its window has focus\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPropertyTypechildWidgeton-clicked() => voidon-primary-click(event: Gdk.Event) => booleanon-secondary-click(event: Gdk.Event) => booleanon-middle-click(event: Gdk.Event) => booleanon-primary-click-release(event: Gdk.Event) => booleanon-secondary-click-release(event: Gdk.Event) => booleanon-middle-click-release(event: Gdk.Event) => booleanon-hover(event: Gdk.Event) => booleanon-hover-lost(event: Gdk.Event) => booleanon-scroll-up(event: Gdk.Event) => booleanon-scroll-down(event: Gdk.Event) => boolean\nconst button = Widget.Button({    child: Widget.Label('click me!'),    onClicked: () => print('hello'),})Calendar\nsubclass of Gtk.Calendar\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPropertyTypeDescriptiondate[number, number, number]readonly [year, month, day]detail(number, number, number) => string | nullon-day-selected() => void\nconst calendar = Widget.Calendar({    showDayNames: true,    showDetails: true,    showHeading: true,    showWeekNumbers: true,    detail: (self, y, m, d) => {        return `<span color=\"white\">${y}. ${m}. ${d}.</span>`    },    onDaySelected: ({ date: [y, m, d] }) => {        print(`${y}. ${m}. ${d}.`)    },})CenterBox\nsubclass of Gtk.Box\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPropertyTypeDescriptionverticalboolsetting vertical: true is the same as orientation: 1start-widgetGtk.Widgetcenter-widgetGtk.Widgetend-widgetGtk.Widget\nconst centerBox = Widget.CenterBox({    spacing: 8,    vertical: false,    startWidget: Widget.Label('left widget'),    centerWidget: Widget.Label('center widget'),    endWidget: Widget.Label('right widget'),})CircularProgress\nsubclass of Gtk.Bin\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPropertyTypeDescriptionstart-atnumberNumber between 0 and 1, e.g 0.75 is the topend-atnumberNumber between 0 and 1invertedbooleanroundedbooleanWether the progress bar should have rounded endsvaluenumberNumber between 0 and 1\nconst progress = Widget.CircularProgress({    css: 'min-width: 50px;'  // its size is min(min-height, min-width)        + 'min-height: 50px;'        + 'font-size: 6px;' // to set its thickness set font-size on it        + 'margin: 4px;' // you can set margin on it        + 'background-color: #131313;' // set its bg color        + 'color: aqua;', // set its fg color    rounded: false,    inverted: false,    startAt: 0.75,    value: battery.bind('percent').as(p => p / 100),    child: Widget.Icon({        icon: battery.bind('icon-name'),    }),})ColorButton\nsubclass of Gtk.ColorButton\n\n\n\n\n\n\n\n\n\n\n\n\n\nPropertyTypeon-color-set() => void\nconst colorbutton = Widget.ColorButton({    onColorSet: ({ rgba: { red, green, blue, alpha } }) => {        print(`rgba(${red * 255}, ${green * 255}, ${blue * 255}, ${alpha})`)    },})DrawingArea\nsubclass of Gtk.DrawingArea\n\n\n\n\n\n\n\n\n\n\n\n\n\nPropertyTypedraw-fn(cr: Cairo.Context, width: number, height: number) => void\nconst drawingarea = Widget.DrawingArea({    widthRequest: 50,    heightRequest: 50,    drawFn: (self, cr, w, h) => {        const center = {            x: w / 2,            y: h / 2,        };\n        cr.setSourceRGBA(1, 1, 1, 1)        cr.setLineWidth(8)        cr.arc(center.x, center.y, 2, 0, Math.PI * 2)        cr.stroke()    },})Entry\nsubclass of Gtk.Entry\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPropertyTypeon-change() => voidon-accept() => void\nconst entry = Widget.Entry({    placeholder_text: 'type here',    text: 'initial text',    visibility: true, // set to false for passwords    onAccept: ({ text }) => print(text),})EventBox\nsubclass of Gtk.EventBox\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPropertyTypechildWidgeton-primary-click(event: Gdk.Event) => booleanon-secondary-click(event: Gdk.Event) => booleanon-middle-click(event: Gdk.Event) => booleanon-primary-click-release(event: Gdk.Event) => booleanon-secondary-click-release(event: Gdk.Event) => booleanon-middle-click-release(event: Gdk.Event) => booleanon-hover(event: Gdk.Event) => booleanon-hover-lost(event: Gdk.Event) => booleanon-scroll-up(event: Gdk.Event) => booleanon-scroll-down(event: Gdk.Event) => boolean\nFileChooserButton\nsubclass of Gtk.FileChooserButton\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPropertyTypeDescriptionon-file-set() => voiduri() => voidconvenience getter for get_uriuris() => voidconvenience getter for get_uris\nconst fbutton = Widget.FileChooserButton({    onFileSet: ({ uri }) => {        print(uri)    },})Fixed\nsubclass of Gtk.Fixed\nNoteGtk.Fixed is not yet subclassed to be declarative and doesn’t have\nany additional properties/methods on top of the base Gtk widget.\nconst fixed = Widget.Fixed({    setup(self) {        self.put(Widget.Label('hello'), 0, 0)        self.put(Widget.Label('hello'), 50, 50)    },})FlowBox\nsubclass of Gtk.FlowBox\nNoteGtk.FlowBox is not yet subclassed to be declarative and doesn’t have\nany additional properties/methods on top of the base Gtk widget.\nconst flowbox = Widget.FlowBox({    setup(self) {        self.add(Widget.Label('hello'))    },})FontButton\nsubclass of Gtk.FontButton\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPropertyTypeDescriptionon-font-set() => void\nconst fontbutton = Widget.FontButton({    onFontSet: ({ font }) => {        print(font)    },})Icon\nsubclass of Gtk.Image\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPropertyTypeDescriptioniconstringName of an icon or path to a filesizenumberForced size\nWidget.Icon({ icon: 'dialog-information-symbolic' })\n// if you only want an icon, it can be shortened like thisWidget.Icon('dialog-information-symbolic')\n// if you don't set a size, it will be computed from css font-sizeWidget.Icon({    icon: 'dialog-information-symbolic',    css: 'font-size: 30px',})\n// NOTE:// setting the icon dynamically has a flicker currently// to fix it, use a forced sizeWidget.Icon({    icon: 'dialog-information-symbolic',    size: 30,})Label\nsubclass of Gtk.Label\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPropertyTypeDescriptionjustificationstringValid values are \"left\", \"center\", \"right\", \"fill\". Same as justify but represented as a string instead of enum.truncatestringValid values are \"none\", \"start\", \"middle\", \"end\". Same as ellipsize but represented as a string instead of enum.\nconst label = Widget.Label({    label: 'some text to show',    justification: 'left',    truncate: 'end',    xalign: 0,    maxWidthChars: 24,    wrap: true,    useMarkup: true,})\n// shorthand for { label: 'hello' }Widget.Label('hello')LevelBar\nsubclass of Gtk.LevelBar\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPropertyTypeDescriptionbar-modestringValid values are \"continuous\", \"discrete\". Same as mode but represented as a string instead of enum.verticalboolsetting vertical: true is the same as orientation: 1\nconst continuous = Widget.LevelBar({    widthRequest: 100,    value: battery.bind(\"percent\").as(p => p / 100),})\nconst discrete = Widget.LevelBar({    widthRequest: 100,    bar_mode: \"discrete\",    max_value: 10,    value: battery.bind(\"percent\").as(p => p / 10),})ListBox\nsubclass of Gtk.ListBox\nNoteGtk.ListBox is not yet subclassed to be declarative and doesn’t have\nany additional properties/methods on top of the base Gtk widget.\nconst listbox = Widget.ListBox({    setup(self) {        self.add(Widget.Label('hello'))    },})Menu\nsubclass of Gtk.Menu\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPropertyTypechildrenMenuItem[]on-popup(flipped_rect: void, final_rect: void, flipped_x: boolean, flipped_y: boolean) => voidon-move-scroll(scroll_type: Gtk.ScrollType) => void\nfunction RightClickMenu() {    const menu = Widget.Menu({        children: [            Widget.MenuItem({                child: Widget.Label('hello'),            }),        ],    })\n    return Widget.Button({        on_primary_click: (_, event) => {            menu.popup_at_pointer(event)        },    })}MenuBar\nsubclass of Gtk.MenuBar\nNoteGtk.MenuBar is not yet subclassed to be declarative and doesn’t have\nany additional properties/methods on top of the base Gtk widget.\nconst menubar = Widget.MenuBar({    setup: self => {        self.append(Widget.Mene())    }})MenuItem\nsubclass of Gtk.MenuItem\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPropertyTypechildWidgeton-activate() => booleanon-select() => booleanon-deselect() => boolean\nconst menu = Widget.Menu({    children: [        Widget.MenuItem({            child: Widget.Label('hello'),            onActivate: () => {                print('clicked')            }        }),    ],})Overlay\nsubclass of Gtk.Overlay\nTakes the size of its first child, then places subsequent children on\ntop of each other and won’t render them outside the container.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPropertyTypeDescriptionchildWidgetChild which will determine the size of the overlayoverlaysWidget[]Overlayed childrenpass-throughbooleanWhether the overlay childs should pass the input through\nProgressBar\nsubclass of Gtk.ProgressBar\nNoteYou might want to use LevelBar instead.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPropertyTypeDescriptionverticalboolSetting vertical: true is the same as orientation: 1valuenumberSame as ProgressBar.fraction\nconst progressbar = Widget.ProgressBar({    value: battery.bind(\"percent\").as(p => p / 100),})Revealer\nsubclass of Gtk.Revealer\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPropertyTypeDescriptionchildWidgettransitionstringValid values are \"none\", \"crossfade\", \"slide_left\", \"slide_right\", \"slide_down\", \"slide_up\". This is transitionType represented as a string instead of enum.\nconst revealer = Widget.Revealer({    revealChild: false,    transitionDuration: 1000,    transition: 'slide_right',    child: Widget.Label('hello!'),    setup: self => self.poll(2000, () => {        self.reveal_child = !self.reveal_child;    }),})Scrollable\nsubclass of Gtk.ScrolledWindow\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPropertyTypeDescriptionchildWidgethscrollstringValid values are \"always, \"automatic\", \"external\", \"never\".vscrollstringValid values are \"always, \"automatic\", \"external\", \"never\".\nconst scrollable = Widget.Scrollable({    hscroll: 'always',    vscroll: 'never',    style: 'min-width: 20px;',    child: Widget.Label('Lorem ipsum dolor sit amet, ' +        'officia excepteur ex fugiat reprehenderit enim ' +        'labore culpa sint ad nisi Lorem pariatur mollit'),})Separator\nsubclass of Gtk.Separator\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPropertyTypeDescriptionverticalboolSetting vertical: true is the same as orientation: 1\nconst separator = Widget.Separator({    vertical: false,})Slider\nsubclass of Gtk.Scale\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPropertyTypeDescriptionverticalboolSetting vertical: true is the same as orientation: 1valuenumberminnumbermaxnumbermarkstuple or numberwhere tuple is [number, string?, Position?], Position is \"top\", \"left, \"right, \"bottom\"on-change(event: Gdk.Event) => void\nWidget.Slider({    onChange: ({ value }) => print(value),    vertical: true,    value: 0,    min: 0,    max: 1,    marks: [        1,        2,        [3, 'label'],        [4, 'label', 'bottom'],    ],})SpinButton\nsubclass of Gtk.SpinButton\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPropertyTypeon-value-changed() => voidrange[min: number, max: number]incements[step: number, page: number]\nconst spinbutton = Widget.SpinButton({    range: [0, 100],    incements: [1, 5],    onValueChanged: ({ value }) => {        print(value)    },})Spinner\nsubclass of Gtk.Spinner\nspinning icon showing that something is loading\nconst spinner = Widget.Spinner()Stack\nsubclass of Gtk.Stack\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPropertyTypeDescriptionchildren{ [string]: Widget }name, Widget key-value pairsshownstringName of the widget to show. This can’t be set on construction, instead the first given widget will be shown.transitionstringtransitionType represented as a string. Valid values are none, crossfade, slide_right, slide_left, slide_up, slide_down, slide_left_right, slide_up_down, over_up, over_down, over_left, over_right, under_up, under_down, under_left, under_right, over_up_down, over_down_up, over_left_right, over_right_left\nconst stack = Widget.Stack({    children: {        'child1': Widget.Label('first child'),        'child2': Widget.Label('second child'),    },    shown: 'child2',})Switch\nsubclass of Gtk.Switch\n\n\n\n\n\n\n\n\n\n\n\n\n\nPropertyTypeon-activate() => void\nconst switch = Widget.Switch({    onActivate: ({ active }) => print(active),})ToggleButton\nsubclass of Gtk.ToggleButton\n\n\n\n\n\n\n\n\n\n\n\n\n\nPropertyTypeon-toggled() => void\nconst togglebutton = Widget.ToggleButton({    onToggled: ({ active }) => print(active),})"}],
    //   },
    //   {
    //     role: "model",
    //     parts: [{ text: "## Widgets\n\nWidget functions return an instance of Gtk.Widget. Most common widgets are subclassed and have a few additional properties. These widgets have some additional properties on top of the base Gtk.Widget ones:\n\n| PropertyType | Description |\n|---|---|\n| **class-names** | string | List of class CSS selectors separated by white space. |\n| **class-names** | Array<string> | List of class CSS selectors. |\n| **css** | string | Inline CSS. e.g label { color: white; }. If no selector is specified * will be assumed. e.g color: white; will be inferred as *{ color: white; }. |\n| **hpack** | string | Horizontal alignment, behaves like halign. halign takes an enum, but for convenience hpack can be given with a string, so one of \"start\", \"center\", \"end\", \"fill\". |\n| **vpack** | string | Vertical alignment. |\n| **cursor** | string | Cursor style when hovering over widgets that have hover states, e.g it won’t work on labels. list of valid values. |\n| **attribute** | any | Any additional attributes on self |\n\n### Setup property\n\n`setup` is a convenience prop to have imperative code inside declarative blocks without setup\n```js\nfunction MyWidget() {\n  const self = Widget.Button();\n  // imperative code\n  return self;\n}using setup\nconst MyWidget = () =>\n  Widget.Button({\n    setup: self => {\n      // imperative code\n    },\n  });\n```\n\n### Attribute property\n\nFor attaching additional attributes on widgets Object.assign or the `attribute` property can be used\n```js\nfunction MyWidget() {\n  const self = Widget.Button();\n  return Object.assign(self, {\n    myPrimitiveProperty: 'anything',\n    myObjectProperty: {\n      something: 'anything',\n      key: 'value',\n    },\n  });\n}\nconst mywidget = MyWidget();\nconsole.log(mywidget.myPrimitiveProperty); // anything\nconsole.log(mywidget.myObjectProperty); // { something: \"anything\", key: \"value\" }\nusing attribute has the benefit of it being a gobject\nwhich means it will signal notify::attribute when it changes\nconst MyWidget = () =>\n  Widget.Button({\n    attribute: 'anything',\n    setup: self =>\n      self.on('notify::attribute', () => {\n        console.log(mywidget.attribute);\n      }),\n  });\nconst mywidget = MyWidget();\nconsole.log(mywidget.attribute); // anything\n// this line will invoke the above console.log in the setup\nmywidget.attribute = 'something else';\nkeep in mind that attribute will only signal if its value changes\nconst MyWidget = () =>\n  Widget.Button({\n    attribute: {\n      someKey: 'value',\n      key: 'value',\n    },\n    setup: self =>\n      self.on('notify::attribute', () => {\n        console.log(mywidget.attribute);\n      }),\n  });\nconst mywidget = MyWidget();\n// this line won't signal, because the attribute is still the same object\nmywidget.attribute.key = 'new value';\n// to have it signal, assign a new object to it\nmywidget.attribute = {\n  ...mywidget.attribute,\n  key: 'new value',\n};\n```\n\n### Common Gtk properties\n\nSome common Gtk.Widget properties you might want for example\n```js\n| PropertyType | Description |\n|---|---|\n| hexpand | boolean | Expand horizontally. |\n| vexpand | boolean | Expand vertically. |\n| sensitive | boolean | Makes the widget interactable. |\n| tooltip-text | string | Tooltip popup when the widget is hovered over. |\n| visible | boolean | Visibility of the widget. Setting this to false doesn’t have any effect if the parent container calls show_all(), for example when you set a Box’s children dynamically. |\n```\n\n### ToggleClassName\n\nIf you don’t want to mutate the `classNames` array, there is `toggleClassName`: `(name: string, enable: boolean) => void`\n```js\nconst label = Widget.Label('example-label');\n// add class name\nlabel.toggleClassName('my-awesome-label', true);\n// remove class name\nlabel.toggleClassName('my-awesome-label', false);\n```\n\nThe properties listed here are just the additional properties on top of their base Gtk."}],
    //   },
    //   {
    //     role: "user",
    //     parts: [{ text: "Variables        Variable is just a simple GObject that holds a value.\nTipThe global Variable is a function that returns an instance\nIf you want to subclass this instead of Service import the classimport { Variable as Var } from 'resource:///com/github/Aylur/ags/variable.js'class MyVar extends Var {    static { Service.register(this) }}Polling and Listening to executables\nconst myVar = Variable('initial-value', {    // listen is what will be passed to Utils.subprocess, so either a string or string[]    listen: App.configDir + '/script.sh',    listen: 'bash -c \"some-command\"',    listen: ['bash', '-c', 'some-command'],\n    // can also take a transform function    listen: [App.configDir + '/script.sh', out => JSON.parse(out)],    listen: [['bash', '-c', 'some-command'], out => JSON.parse(out)],\n    // poll is a [interval: number, cmd: string[] | string, transform: (string) => any]    // cmd is what gets passed to Utils.execAsync    poll: [1000, 'some-command'],    poll: [1000, 'some-command', out => 'transformed output: ' + out],    poll: [1000, ['bash', '-c', 'some-command'], out => 'transformed output: ' + out],\n    // or [number, function]    poll: [1000, () => { return new Date(); }],    poll: [1000, Math.random],});Updating its value\nmyVar.value = 'new-value'myVar.setValue('new-value')Cautionusing setValue will force a new value and thus signal changed,\nwhile setting value only signal if it gets a new valueconst myVar = Variable({ key: \"value\" })const value = myVar.valuevalue[\"new-key\"] = \"value\"myVar.value = value // won't emit, because its still the same objectmyVar.setValue(value) // will emit the signalGetting its value\nprint(myVar.value)print(myVar.getValue())Temporarily stopping it\nvariable.stopListen() // this kills the subprocessvariable.stopPoll()Starting it\nIt will start on construction, no need to explicitly call this.\nvariable.startListen() // launches the subprocess againvariable.startPoll()Getting if its active\nprint(variable.isListening)print(variable.isPolling)Usage with widgets\nconst label = Widget.Label({    label: myVar.bind(),\n    // optional transform method    label: myVar.bind().as(value => value.toString()),\n    // hook to do more than an assignment on changed    setup: self => self.hook(myVar, () => {        self.label = myVar.value.toString();    })})Connecting to it directly\nmyVar.connect('changed', ({ value }) => {    console.log(value);});Dispose if no longer needed\nThis will stop the interval and force exit the subprocess\nmyVar.dispose();Example RAM and CPU usage\nconst divide = ([total, free]) => free / total\nconst cpu = Variable(0, {    poll: [2000, 'top -b -n 1', out => divide([100, out.split('\\n')        .find(line => line.includes('Cpu(s)'))        .split(/\\s+/)[1]        .replace(',', '.')])],})\nconst ram = Variable(0, {    poll: [2000, 'free', out => divide(out.split('\\n')        .find(line => line.includes('Mem:'))        .split(/\\s+/)        .splice(1, 2))],})\nconst cpuProgress = Widget.CircularProgress({    value: cpu.bind()})\nconst ramProgress = Widget.CircularProgress({    value: ram.bind()})Derived Variables\nconst a = Variable(2)const b = Variable(3)\n// first argument is a list of dependencies// second argument is a transform functionconst c = Utils.derive([a, b], (a, b) => {    return a * b})"}],
    //   },
    //   {
    //     role: "model",
    //     parts: [{ text: "## Variables\n\nVariable is just a simple GObject that holds a value.\n\n**Tip**\n\n- The global `Variable` is a function that returns an instance\n- If you want to subclass this instead of `Service` import the class\n\n```js\nimport { Variable as Var } from 'resource:///com/github/Aylur/ags/variable.js';\nclass MyVar extends Var {\n  static {\n    Service.register(this);\n  }\n}\n```\n\n### Polling and Listening to executables\n\n```js\nconst myVar = Variable('initial-value', {\n  // listen is what will be passed to Utils.subprocess, so either a string or string[]\n  listen: App.configDir + '/script.sh',\n  listen: 'bash -c \"some-command\"',\n  listen: ['bash', '-c', 'some-command'],\n  // can also take a transform function\n  listen: [App.configDir + '/script.sh', out => JSON.parse(out)],\n  listen: [['bash', '-c', 'some-command'], out => JSON.parse(out)],\n  // poll is a [interval: number, cmd: string[] | string, transform: (string) => any]\n  // cmd is what gets passed to Utils.execAsync\n  poll: [1000, 'some-command'],\n  poll: [1000, 'some-command', out => 'transformed output: ' + out],\n  poll: [1000, ['bash', '-c', 'some-command'], out => 'transformed output: ' + out],\n  // or [number, function]\n  poll: [1000, () => {\n    return new Date();\n  }],\n  poll: [1000, Math.random],\n});\n```\n\n### Updating its value\n\n```js\nmyVar.value = 'new-value';\nmyVar.setValue('new-value');\n```\n\n**Caution**\n\n- Using `setValue` will force a new value and thus signal `changed`, while setting `value` only signal if it gets a new value\n\n```js\nconst myVar = Variable({ key: 'value' });\nconst value = myVar.value;\nvalue['new-key'] = 'value';\nmyVar.value = value; // won't emit, because its still the same object\nmyVar.setValue(value); // will emit the signal\n```\n\n### Getting its value\n\n```js\nprint(myVar.value);\nprint(myVar.getValue());\n```\n\n### Temporarily stopping it\n\n```js\nvariable.stopListen(); // this kills the subprocess\nvariable.stopPoll();\n```\n\n### Starting it\n\n> It will start on construction, no need to explicitly call this.\n\n```js\nvariable.startListen(); // launches the subprocess again\nvariable.startPoll();\n```\n\n### Getting if its active\n\n```js\nprint(variable.isListening);\nprint(variable.isPolling);\n```\n\n### Usage with widgets\n\n```js\nconst label = Widget.Label({\n  label: myVar.bind(),\n  // optional transform method\n  label: myVar.bind().as(value => value.toString()),\n  // hook to do more than an assignment on changed\n  setup: self =>\n    self.hook(myVar, () => {\n      self.label = myVar.value.toString();\n    }),\n});\n```\n\n### Connecting to it directly\n\n```js\nmyVar.connect('changed', ({ value }) => {\n  console.log(value);\n});\n```\n\n### Dispose if no longer needed\n\n> This will stop the interval and force exit the subprocess\n\n```js\nmyVar.dispose();\n```\n\n### Example RAM and CPU usage\n\n```js\nconst divide = ([total, free]) => free / total;\nconst cpu = Variable(0, {\n  poll: [\n    2000,\n    'top -b -n 1',\n    out =>\n      divide([\n        100,\n        out\n          .split('\\n')\n          .find(line => line.includes('Cpu(s)'))\n          .split(/\\s+/)[1]\n          .replace(',', '.'),\n      ]),\n  ],\n});\nconst ram = Variable(0, {\n  poll: [\n    2000,\n    'free',\n    out =>\n      divide(\n        out\n          .split('\\n')\n          .find(line => line.includes('Mem:'))\n          .split(/\\s+/)\n          .splice(1, 2)\n      ),\n  ],\n});\nconst cpuProgress = Widget.CircularProgress({\n  value: cpu.bind(),\n});\nconst ramProgress = Widget.CircularProgress({\n  value: ram.bind(),\n});\n```\n\n### Derived Variables\n\n```js\nconst a = Variable(2);\nconst b = Variable(3);\n// first argument is a list of dependencies\n// second argument is a transform function\nconst c = Utils.derive([a, b], (a, b) => {\n  return a * b;\n});\n```"}],
    //   },
    //   {
    //     role: "user",
    //     parts: [{ text: "Services        A Service is an instance of a GObject.Object\nthat emits signals when its state changes.\nWidgets can connect to them and execute a callback function on their signals\nwhich are usually functions that updates the widget’s properties.\nWidget.Label({    // the signal is 'changed' if not specified    // [Service, callback, signal = 'changed']    setup: self => self.hook(someService, function(self, ...args) {        // there can be other arguments based on signals        self.label = 'new label'    }, 'changed')})Widget.Label({    label: someService.bind('service-prop').as(serviceProp => {        return `transformed ${serviceProp}`    }),})Utility to have multiple bindings as one\nWidget.Label({    label: Utils.merge([service1.bind(\"prop1\"), service2.bind(\"prop2\")], (p1, p2) => {        return `service1.prop1: ${p1}, service2.prop2: ${p2}`    }),})Services can be also connected outside of widgets\nsomeService.connect('changed', (service, ...args) => {    print(service, ...args)})CautionIf you reference a widget inside someService.connect, make sure to\nhandle disconnection as well if that widget is destroyed\nList of builtin services\nuse Service.import\nconst battery = await Service.import('battery')or if you prefer static import\nimport { battery } from 'resource:///com/github/Aylur/ags/service/battery.js';CautionImport default and don’t import the service class from the module,\nunless you need the type when using typescript.// this is the service singleton instanceimport Battery from 'resource:///com/github/Aylur/ags/service/battery.js';\n// this is also the service singleton instanceimport { battery } from 'resource:///com/github/Aylur/ags/service/battery.js';\nBattery === battery // true// DON'T import it this way, this is the classimport { Battery } from 'resource:///com/github/Aylur/ags/service/battery.js';"}],
    //   },
    //   {
    //     role: "model",
    //     parts: [{ text: "## Services\n\nA Service is an instance of a GObject.Object that emits signals when its state changes. Widgets can connect to them and execute a callback function on their signals which are usually functions that updates the widget’s properties.\n\n```js\nWidget.Label({\n  // the signal is 'changed' if not specified\n  // [Service, callback, signal = 'changed']\n  setup: self =>\n    self.hook(someService, function(self, ...args) {\n      // there can be other arguments based on signals\n      self.label = 'new label';\n    }, 'changed'),\n});\nWidget.Label({\n  label: someService\n    .bind('service-prop')\n    .as(serviceProp => {\n      return `transformed ${serviceProp}`;\n    }),\n});\n```\n\n### Utility to have multiple bindings as one\n\n```js\nWidget.Label({\n  label: Utils.merge(\n    [service1.bind('prop1'), service2.bind('prop2')],\n    (p1, p2) => {\n      return `service1.prop1: ${p1}, service2.prop2: ${p2}`;\n    }\n  ),\n});\n```\n\n### Services can be also connected outside of widgets\n\n```js\nsomeService.connect('changed', (service, ...args) => {\n  print(service, ...args);\n});\n```\n\n### Caution\n\nIf you reference a widget inside `someService.connect`, make sure to handle disconnection as well if that widget is destroyed\n\n### List of builtin services\n\nUse `Service.import`\n\n```js\nconst battery = await Service.import('battery');\n```\n\nOr if you prefer static import\n\n```js\nimport { battery } from 'resource:///com/github/Aylur/ags/service/battery.js';\n```\n\n### Caution\n\n- Import default and don’t import the service class from the module, unless you need the type when using typescript.\n\n```js\n// this is the service singleton instance\nimport Battery from 'resource:///com/github/Aylur/ags/service/battery.js';\n\n// this is also the service singleton instance\nimport { battery } from 'resource:///com/github/Aylur/ags/service/battery.js';\n\nBattery === battery; // true\n\n// DON'T import it this way, this is the class\nimport { Battery } from 'resource:///com/github/Aylur/ags/service/battery.js';\n```"}],
    //   },
    //   {
    //     role: "user",
    //     parts: [{ text: "Utils        Running external commands\nSynchronously\nfunction exec(cmd: string): stringThis is synchronous, meaning it will block the eventloop\nconst echo = Utils.exec('echo \"Hi Mom\"') // returns stringconsole.log(echo) // logs \"Hi Mom\"const uptime = Utils.exec(`bash -c \"uptime | awk '{print $3}' | tr ',' ' '\"`)console.log(uptime)Asynchronously\nfunction execAsync(cmd: string | string[]): Promise<string>;This won’t block,\nUtils.execAsync(['echo', 'Hi Mom'])    .then(out => print(out))    .catch(err => print(err));NoteBoth exec and execAsync launches the given binary on its own,\nmeaning if you want to use | pipes or any other shell features\nthen you have to run it with bash.Utils.execAsync(['bash', '-c', 'cmd | cmd && cmd']);Utils.exec('bash -c \"cmd | cmd && cmd\"');Running external scripts\nfunction subprocess(    cmd: string | string[],    callback: (out: string) => void,    onError = logError,    bind?: Gtk.Widget,): Gio.SubprocessTakes two to four arguments, returns Gio.Subprocess\nconst proc = Utils.subprocess(    // command to run, in an array just like execAsync    ['bash', '-c', 'path-to-bash-script'],\n    // callback when the program outputs something to stdout    (output) => print(output),\n    // callback on error    (err) => logError(err),\n    // optional widget parameter    // if the widget is destroyed the subprocess is forced to quit    widget,)Killing the process\nproc.force_exit()Writing and reading files\nfunction readFile(file: string | Gio.File): stringfunction readFileAsync(file: string | Gio.File): Promise<string>\nfunction writeFileSync(string: string, path: string): Gio.Filefunction writeFile(string: string, path: string): Promise<Gio.File>Synchronously\nconst contents = Utils.readFile('/path/to/file')\nUtils.writeFileSync('/path/to/file', 'some content')Asynchronously\nUtils.readFileAsync('path-to-file')    .then(content => print('contents of the file: ' + content))    .catch(logError)\nUtils.writeFile('Contents: Hi Mom', 'path-to-file')    .then(file => print('file is the Gio.File'))    .catch(err => print(err))Monitoring files and directories\nfunction monitorFile(    path: string,    callback?: (file: Gio.File, event: Gio.FileMonitorEvent) => void,    flags = Gio.FileMonitorFlags.NONE,): Gio.FileMonitor | nullconst monitor = Utils.monitorFile('/path/to/file', (file, event) => {    print(Utils.readFile(file), event)})CautionmonitorFile only reports events that a user-space program\ntriggers through the filesystem API. As a result, it does not catch\nremote events that occur on network filesystems.\nFurthermore, most pseudo-filesystems such as /proc, /sys and /dev/pts\ncannot be monitored.\nCanceling the monitor\nmonitor.cancel()Timeout and Interval\nYou can use native JS setTimeout and setInterval, they return a GLib.Source\nTimeout\nconst source = setTimeout(() => { /* callback */ }, 1000)Interval\nconst source = setInterval(() => { /* callback */ }, 1000)To cancel them use GLib.Source.destroy\nsource.destroy()You can use the ones from Utils\nfunction interval(    interval: number,    callback: () => void,    bind?: Gtk.Widget,): number\nfunction timeout(    ms: number,    callback: () => void,): numberconst id = Utils.timeout(1000, () => {  // runs with a second delay})The widget parameter is optional\nconst id = Utils.interval(1000, () => {  // runs immediately and once every second})If you pass a widget to Utils.interval, it will automatically be canceled,\nwhen the widget is destroyed\nconst widget = Widget.Label()const id = Utils.interval(1000, () => {}, widget)widget.destroy()To cancel them use GLib.source_remove\nimport GLib from 'gi://GLib'GLib.source_remove(id)Lookup an Icon name\nconst icon = Utils.lookUpIcon('dialog-information-symbolic')\nif (icon) {    // icon is the corresponding Gtk.IconInfo}else {    // null if it wasn't found in the current Icon Theme}Fetch\nshould be pretty close to the web api\nUtils.fetch('http://wttr.in/?format=3')    .then(res => res.text())    .then(print)    .catch(console.error)Authentication\nauthenticate a user using pam\nNoteon NixOS make sure you have security.pam.services.ags = {} in configuration.nix\nUtils.authenticate('password')    .then(() => print('authentication successful'))    .catch(err => logError(err, 'unsuccessful'))\nUtils.authenticateUser(\"username\", \"password\")    .then(() => print(\"authentication successful\"))    .catch(err => logError(err, 'unsuccessful'))Send Notifications\nUtils.notify('summary', 'body', 'icon-name')const id = await Utils.notify({    summary: 'Title',    body: 'Description',    iconName: 'icon-name',    actions: {        'Click Me': () => print('clicked')    }})\nconst notifications = await Service.import('notifications')const n = notifications.getNotification(id)"}],
    //   },
    //   {
    //     role: "model",
    //     parts: [{ text: "## Utils\n\n### Running external commands\n\n#### Synchronously\n\n```js\nfunction exec(cmd: string): string\n```\n\nThis is synchronous, meaning it will block the event loop\n\n```js\nconst echo = Utils.exec('echo \"Hi Mom\"'); // returns string\nconsole.log(echo); // logs \"Hi Mom\"\nconst uptime = Utils.exec(\n  `bash -c \"uptime | awk '{print $3}' | tr ',' ' '\"`\n);\nconsole.log(uptime);\n```\n\n#### Asynchronously\n\n```js\nfunction execAsync(cmd: string | string[]): Promise"}],
    //   },
    //   {
    //     role: "user",
    //     parts: [{ text: "Subclassing GTK Widgets        Using Gtk.Widgets not builtin\nUse them like regular GTK widgets\nimport Gtk from 'gi://Gtk'\nconst calendar = new Gtk.Calendar({    showDayNames: false,    showHeading: true,})You can subclass Gtk.Widget not builtin to behave like AGS widgets.\nconst Calendar = Widget.subclass(Gtk.Calendar)\nconst myCalendar = Calendar({    showDayNames: false,    showHeading: true,\n    // now you can set AGS props    className: 'my-calendar',    setup(self) {        self.bind()    }})TipCalendar is available on Widget\nNoteOpen up an issue/PR if you want to see a widget to be available on Widget by default.\nCustom Subclassing\nUsually in GTK custom widgets are achieved by subclassing.\nThe idea behind AGS is to use functions that create widgets\nand utilize closures.\nfunction CounterButton(({ color = 'aqua', ...rest })) {    const count = Variable(0)\n    const label = Widget.Label({        label: count.bind().as(v => `count: ${v}`),        style: `color: ${color}`,    })\n    return Widget.Button({        ...rest, // spread passed parameters        child: label,        onClicked: () => count++,    })}\n// then simply call itconst button = CounterButton({    color: 'blue',    className: 'my-widget',})This approach comes with the limitation that parameters passed to these\nfunctions are that, just parameters and not GObject properties.\nIf you still want to subclass, you can do so by subclassing\na Gtk.WIdget and registering it Widget.register.\nclass CounterButton extends Gtk.Button {    static {        Widget.register(this, {            properties: {                'count': ['int', 'rw']            }        })    }\n    // the super constructor will take care of setting the count prop    // so you don't have to explicitly set count in the constructor    constructor(props) {        super(props)\n        const label = new Gtk.Label({            label: `${this.count}`,        })\n        this.add(label)\n        this.connect('clicked', () => {            this.count++            label.label = `${this.count}`        })    }\n    get count() {        return this._count || 0    }\n    set count(num) {        this._count = num        this.notify('count')    }}You can now construct it like any other Gtk.Widget with the new keyword.\nconst counterButton = new CounterButton({    count: 0,\n    // you can set AGS widget props on it    className: '',})\ncounterButton.connect('notify::count', ({ count }) => {    print(count);})\ncounterButton.count += 1TipYou will never actually need to subclass, you can fake gobject props using Variablesfunction CounterButton({ count, ...props }) {    const counter = Variable(count)\n    const button = Widget.Button({        on_clicked: () => counter.value += 1,        child: Widget.Label({            label: counter.bind().as(c => `${c}`),        }),        ...props,    })\n    return Object.assign(button, {        count: counter,    })}\nconst counterButton = CounterButton({    count: 0,})\ncounterButton.count.connect(\"changed\", ({ value }) => {    print(value)})\ncounterButton.count.value += 1"}],
    //   },
    //   {
    //     role: "model",
    //     parts: [{ text: "## Subclassing GTK Widgets\n\n### Using Gtk.Widgets not builtin\n\nUse them like regular GTK widgets\n\n```js\nimport Gtk from 'gi://Gtk';\n\nconst calendar = new Gtk.Calendar({\n  showDayNames: false,\n  showHeading: true,\n});\n```\n\nYou can subclass Gtk.Widget not builtin to behave like AGS widgets.\n\n```js\nconst Calendar = Widget.subclass(Gtk.Calendar);\n\nconst myCalendar = Calendar({\n  showDayNames: false,\n  showHeading: true,\n  // now you can set AGS props\n  className: 'my-calendar',\n  setup(self) {\n    self.bind();\n  },\n});\n```\n\n**Tip**\n\n- Calendar is available on Widget\n\n**Note**\n\n- Open up an issue/PR if you want to see a widget to be available on `Widget` by default.\n\n### Custom Subclassing\n\nUsually in GTK custom widgets are achieved by subclassing. The idea behind AGS is to use functions that create widgets and utilize closures.\n\n```js\nfunction CounterButton(({ color = 'aqua', ...rest }) {\n  const count = Variable(0);\n  const label = Widget.Label({\n    label: count.bind().as(v => `count: ${v}`),\n    style: `color: ${color}`,\n  });\n  return Widget.Button({\n    ...rest, // spread passed parameters\n    child: label,\n    onClicked: () => count++,\n  });\n}\n// then simply call it\nconst button = CounterButton({\n  color: 'blue',\n  className: 'my-widget',\n});\n```\n\nThis approach comes with the limitation that parameters passed to these functions are that, just parameters and not GObject properties. If you still want to subclass, you can do so by subclassing a Gtk.WIdget and registering it `Widget.register`.\n\n```js\nclass CounterButton extends Gtk.Button {\n  static {\n    Widget.register(this, {\n      properties: {\n        'count': ['int', 'rw'],\n      },\n    });\n  }\n\n  // the super constructor will take care of setting the count prop\n  // so you don't have to explicitly set count in the constructor\n  constructor(props) {\n    super(props);\n    const label = new Gtk.Label({\n      label: `${this.count}`,\n    });\n    this.add(label);\n    this.connect('clicked', () => {\n      this.count++;\n      label.label = `${this.count}`;\n    });\n  }\n\n  get count() {\n    return this._count || 0;\n  }\n\n  set count(num) {\n    this._count = num;\n    this.notify('count');\n  }\n}\n```\n\nYou can now construct it like any other Gtk.Widget with the `new` keyword.\n\n```js\nconst counterButton = new CounterButton({\n  count: 0,\n  // you can set AGS widget props on it\n  className: '',\n});\n\ncounterButton.connect('notify::count', ({ count }) => {\n  print(count);\n});\n\ncounterButton.count += 1;\n```\n\n**Tip**\n\nYou will never actually need to subclass, you can fake gobject props using Variables\n\n```js\nfunction CounterButton({ count, ...props }) {\n  const counter = Variable(count);\n  const button = Widget.Button({\n    on_clicked: () => counter.value += 1,\n    child: Widget.Label({\n      label: counter.bind().as(c => `${c}`),\n    }),\n    ...props,\n  });\n  return Object.assign(button, {\n    count: counter,\n  });\n}\n\nconst counterButton = CounterButton({\n  count: 0,\n});\ncounterButton.count.connect('changed', ({ value }) => {\n  print(value);\n});\ncounterButton.count.value += 1;\n```"}],
    //   },
    //   {
    //     role: "user",
    //     parts: [{ text: "this is an example of a serviceclass BrightnessService extends Service {    // every subclass of GObject.Object has to register itself    static {        // takes three arguments        // the class itself        // an object defining the signals        // an object defining its properties        Service.register(            this,            {                // 'name-of-signal': [type as a string from GObject.TYPE_<type>],                'screen-changed': ['float'],            },            {                // 'kebab-cased-name': [type as a string from GObject.TYPE_<type>, 'r' | 'w' | 'rw']                // 'r' means readable                // 'w' means writable                // guess what 'rw' means                'screen-value': ['float', 'rw'],            },        );    }\n    // this Service assumes only one device with backlight    #interface = Utils.exec(\"sh -c 'ls -w1 /sys/class/backlight | head -1'\");\n    // # prefix means private in JS    #screenValue = 0;    #max = Number(Utils.exec('brightnessctl max'));\n    // the getter has to be in snake_case    get screen_value() {        return this.#screenValue;    }\n    // the setter has to be in snake_case too    set screen_value(percent) {        if (percent < 0)            percent = 0;\n        if (percent > 1)            percent = 1;\n        Utils.execAsync(`brightnessctl set ${percent * 100}% -q`);        // the file monitor will handle the rest    }\n    constructor() {        super();\n        // setup monitor        const brightness = `/sys/class/backlight/${this.#interface}/brightness`;        Utils.monitorFile(brightness, () => this.#onChange());\n        // initialize        this.#onChange();    }\n    #onChange() {        this.#screenValue = Number(Utils.exec('brightnessctl get')) / this.#max;\n        // signals have to be explicitly emitted        this.emit('changed'); // emits \"changed\"        this.notify('screen-value'); // emits \"notify::screen-value\"\n        // or use Service.changed(propName: string) which does the above two        // this.changed('screen-value');\n        // emit screen-changed with the percent as a parameter        this.emit('screen-changed', this.#screenValue);    }\n    // overwriting the connect method, let's you    // change the default event that widgets connect to    connect(event = 'screen-changed', callback) {        return super.connect(event, callback);    }}\n// the singleton instanceconst service = new BrightnessService;\n// export to use in other modulesexport default service;"}],
    //   },
    //   {
    //     role: "model",
    //     parts: [{ text: "```js\nclass BrightnessService extends Service {\n  // every subclass of GObject.Object has to register itself\n  static {\n    // takes three arguments\n    // the class itself\n    // an object defining the signals\n    // an object defining its properties\n    Service.register(\n      this,\n      {\n        // 'name-of-signal': [type as a string from GObject.TYPE_"}],
    //   },
    //   {
    //     role: "user",
    //     parts: [{ text: "how to use this service import brightness from './brightness.js';\nconst slider = Widget.Slider({    on_change: self => brightness.screen_value = self.value,    value: brightness.bind('screen-value'),});\nconst label = Label({    label: brightness.bind('screen-value').as(v => `${v}`),    setup: self => self.hook(brightness, (self, screenValue) => {        // screenValue is the passed parameter from the 'screen-changed' signal        self.label = screenValue ?? 0;\n        // NOTE:        // since hooks are run upon construction        // the passed screenValue will be undefined the first time\n        // all three are valid        self.label = `${brightness.screenValue}`;        self.label = `${brightness.screen_value}`;        self.label = `${brightness['screen-value']}`;\n    }, 'screen-changed'),});"}],
    //   },
    //   {
    //     role: "model",
    //     parts: [{ text: "```js\nimport brightness from './brightness.js';\n\nconst slider = Widget.Slider({\n  on_change: self => (brightness.screen_value = self.value),\n  value: brightness.bind('screen-value'),\n});\n\nconst label = Label({\n  label: brightness.bind('screen-value').as(v => `${v}`),\n  setup: self =>\n    self.hook(brightness, (self, screenValue) => {\n      // screenValue is the passed parameter from the 'screen-changed' signal\n      self.label = screenValue ?? 0;\n      // NOTE:\n      // since hooks are run upon construction\n      // the passed screenValue will be undefined the first time\n      // all three are valid\n      self.label = `${brightness.screenValue}`;\n      self.label = `${brightness.screen_value}`;\n      self.label = `${brightness['screen-value']}`;\n    }, 'screen-changed'),\n});\n```"}],
    //   },
    //   {
    //     role: "user",
    //     parts: [{ text: "Subclassing GTK Widgets        Using Gtk.Widgets not builtin\nUse them like regular GTK widgets\nimport Gtk from 'gi://Gtk'\nconst calendar = new Gtk.Calendar({    showDayNames: false,    showHeading: true,})You can subclass Gtk.Widget not builtin to behave like AGS widgets.\nconst Calendar = Widget.subclass(Gtk.Calendar)\nconst myCalendar = Calendar({    showDayNames: false,    showHeading: true,\n    // now you can set AGS props    className: 'my-calendar',    setup(self) {        self.bind()    }})TipCalendar is available on Widget\nNoteOpen up an issue/PR if you want to see a widget to be available on Widget by default.\nCustom Subclassing\nUsually in GTK custom widgets are achieved by subclassing.\nThe idea behind AGS is to use functions that create widgets\nand utilize closures.\nfunction CounterButton(({ color = 'aqua', ...rest })) {    const count = Variable(0)\n    const label = Widget.Label({        label: count.bind().as(v => `count: ${v}`),        style: `color: ${color}`,    })\n    return Widget.Button({        ...rest, // spread passed parameters        child: label,        onClicked: () => count++,    })}\n// then simply call itconst button = CounterButton({    color: 'blue',    className: 'my-widget',})This approach comes with the limitation that parameters passed to these\nfunctions are that, just parameters and not GObject properties.\nIf you still want to subclass, you can do so by subclassing\na Gtk.WIdget and registering it Widget.register.\nclass CounterButton extends Gtk.Button {    static {        Widget.register(this, {            properties: {                'count': ['int', 'rw']            }        })    }\n    // the super constructor will take care of setting the count prop    // so you don't have to explicitly set count in the constructor    constructor(props) {        super(props)\n        const label = new Gtk.Label({            label: `${this.count}`,        })\n        this.add(label)\n        this.connect('clicked', () => {            this.count++            label.label = `${this.count}`        })    }\n    get count() {        return this._count || 0    }\n    set count(num) {        this._count = num        this.notify('count')    }}You can now construct it like any other Gtk.Widget with the new keyword.\nconst counterButton = new CounterButton({    count: 0,\n    // you can set AGS widget props on it    className: '',})\ncounterButton.connect('notify::count', ({ count }) => {    print(count);})\ncounterButton.count += 1TipYou will never actually need to subclass, you can fake gobject props using Variablesfunction CounterButton({ count, ...props }) {    const counter = Variable(count)\n    const button = Widget.Button({        on_clicked: () => counter.value += 1,        child: Widget.Label({            label: counter.bind().as(c => `${c}`),        }),        ...props,    })\n    return Object.assign(button, {        count: counter,    })}\nconst counterButton = CounterButton({    count: 0,})\ncounterButton.count.connect(\"changed\", ({ value }) => {    print(value)})\ncounterButton.count.value += 1"}],
    //   },
    //   {
    //     role: "model",
    //     parts: [{ text: "## Subclassing GTK Widgets\n\n### Using Gtk.Widgets not builtin\n\nUse them like regular GTK widgets\n\n```js\nimport Gtk from 'gi://Gtk';\n\nconst calendar = new Gtk.Calendar({\n  showDayNames: false,\n  showHeading: true,\n});\n```\n\nYou can subclass Gtk.Widget not builtin to behave like AGS widgets.\n\n```js\nconst Calendar = Widget.subclass(Gtk.Calendar);\n\nconst myCalendar = Calendar({\n  showDayNames: false,\n  showHeading: true,\n  // now you can set AGS props\n  className: 'my-calendar',\n  setup(self) {\n    self.bind();\n  },\n});\n```\n\n**Tip**\n\n- Calendar is available on Widget\n\n**Note**\n\n- Open up an issue/PR if you want to see a widget to be available on `Widget` by default.\n\n### Custom Subclassing\n\nUsually in GTK custom widgets are achieved by subclassing. The idea behind AGS is to use functions that create widgets and utilize closures.\n\n```js\nfunction CounterButton(({ color = 'aqua', ...rest }) {\n  const count = Variable(0);\n  const label = Widget.Label({\n    label: count.bind().as(v => `count: ${v}`),\n    style: `color: ${color}`,\n  });\n  return Widget.Button({\n    ...rest, // spread passed parameters\n    child: label,\n    onClicked: () => count++,\n  });\n}\n// then simply call it\nconst button = CounterButton({\n  color: 'blue',\n  className: 'my-widget',\n});\n```\n\nThis approach comes with the limitation that parameters passed to these functions are that, just parameters and not GObject properties. If you still want to subclass, you can do so by subclassing a Gtk.WIdget and registering it `Widget.register`.\n\n```js\nclass CounterButton extends Gtk.Button {\n  static {\n    Widget.register(this, {\n      properties: {\n        'count': ['int', 'rw'],\n      },\n    });\n  }\n\n  // the super constructor will take care of setting the count prop\n  // so you don't have to explicitly set count in the constructor\n  constructor(props) {\n    super(props);\n    const label = new Gtk.Label({\n      label: `${this.count}`,\n    });\n    this.add(label);\n    this.connect('clicked', () => {\n      this.count++;\n      label.label = `${this.count}`;\n    });\n  }\n\n  get count() {\n    return this._count || 0;\n  }\n\n  set count(num) {\n    this._count = num;\n    this.notify('count');\n  }\n}\n```\n\nYou can now construct it like any other Gtk.Widget with the `new` keyword.\n\n```js\nconst counterButton = new CounterButton({\n  count: 0,\n  // you can set AGS widget props on it\n  className: '',\n});\n\ncounterButton.connect('notify::count', ({ count }) => {\n  print(count);\n});\n\ncounterButton.count += 1;\n```\n\n**Tip**\n\nYou will never actually need to subclass, you can fake gobject props using Variables\n\n```js\nfunction CounterButton({ count, ...props }) {\n  const counter = Variable(count);\n  const button = Widget.Button({\n    on_clicked: () => counter.value += 1,\n    child: Widget.Label({\n      label: counter.bind().as(c => `${c}`),\n    }),\n    ...props,\n  });\n  return Object.assign(button, {\n    count: counter,\n  });\n}\n\nconst counterButton = CounterButton({\n  count: 0,\n});\ncounterButton.count.connect('changed', ({ value }) => {\n  print(value);\n});\ncounterButton.count.value += 1;\n```"}],
    //   },
	{ role: "user", parts: [{ text: "find the derivative of (x-438)/(x^2+23x-7)+x^x" }], },
        { role: "model", parts: [{ text: "## Derivative\n```latex\n\\[\n\\frac{d}{dx}\\left(\\frac{x - 438}{x^2 + 23x - 7} + x^x\\right) = \\frac{-(x^2+23x-7)-(x-438)(2x+23)}{(x^2+23x-7)^2} + x^x(\\ln(x) + 1)\n\\]\n```" }], },
        { role: "user", parts: [{ text: "write the double angle formulas" }], },
        { role: "model", parts: [{ text: "## Double angle formulas\n```latex\n\\[\n\\sin(2\theta) = 2\\sin(\\theta)\\cos(\\theta)\n\\]\n\\\\\n\\[\n\\cos(2\\theta) = \\cos^2(\\theta) - \\sin^2(\\theta)\n\\]\n\\\\\n\\[\n\\tan(2\theta) = \\frac{2\\tan(\\theta)}{1 - \\tan^2(\\theta)}\n\\]\n```" }], },
    ];


if (!fileExists(`${GLib.get_user_config_dir()}/gemini_history.json`)) {
    Utils.execAsync([`bash`, `-c`, `touch ${GLib.get_user_config_dir()}/gemini_history.json`]).catch(print);
    Utils.writeFile('[ ]', `${GLib.get_user_config_dir()}/gemini_history.json`).catch(print);
}

const KEY_FILE_LOCATION = `${GLib.get_user_config_dir()}/gemini_key_ags.txt`;
const APIDOM_FILE_LOCATION = `${GLib.get_user_config_dir()}/google_api_dom.txt`;
function replaceapidom(URL) {
    if (fileExists(APIDOM_FILE_LOCATION)) {
        var contents = Utils.readFile(APIDOM_FILE_LOCATION).trim();
        var URL = URL.toString().replace("generativelanguage.googleapis.com", contents);
    }
    return URL;
}
const CHAT_MODELS = ["gemini-pro"]
const ONE_CYCLE_COUNT = 3;

class GeminiMessage extends Service {
    static {
        Service.register(this,
            {
                'delta': ['string'],
            },
            {
                'content': ['string'],
                'thinking': ['boolean'],
                'done': ['boolean'],
            });
    }

    _role = '';
    _parts = [{ text: '' }];
    _thinking = false;
    _done = false;
    _rawData = '';

    constructor(role, content, thinking = false, done = false) {
        super();
        this._role = role;
        this._parts = [{ text: content }];
        this._thinking = thinking;
        this._done = done;
    }

    get rawData() { return this._rawData }
    set rawData(value) { this._rawData = value }

    get done() { return this._done }
    set done(isDone) { this._done = isDone; this.notify('done') }

    get role() { return this._role }
    set role(role) { this._role = role; this.emit('changed') }

    get content() {
        return this._parts.map(part => part.text).join();
    }
    set content(content) {
        this._parts = [{ text: content }];
        this.notify('content')
        this.emit('changed')
    }

    get parts() { return this._parts }

    get label() { return this._parserState.parsed + this._parserState.stack.join('') }

    get thinking() { return this._thinking }
    set thinking(thinking) {
        this._thinking = thinking;
        this.notify('thinking')
        this.emit('changed')
    }

    addDelta(delta) {
        if (this.thinking) {
            this.thinking = false;
            this.content = delta;
        }
        else {
            this.content += delta;
        }
        this.emit('delta', delta);
    }

    parseSection() {
        if (this._thinking) {
            this._thinking = false;
            this._parts[0].text = '';
        }
        const parsedData = JSON.parse(this._rawData);
        if (!parsedData.candidates)
            this._parts[0].text += `Blocked: ${parsedData.promptFeedback.blockReason}`;
        else {
            const delta = parsedData.candidates[0].content.parts[0].text;
            this._parts[0].text += delta;
        }
        // this.emit('delta', delta);
        this.notify('content');
        this._rawData = '';
    }
}

class GeminiService extends Service {
    static {
        Service.register(this, {
            'initialized': [],
            'clear': [],
            'newMsg': ['int'],
            'hasKey': ['boolean'],
        });
    }

    _assistantPrompt = userOptions.ai.enhancements;
    _cycleModels = true;
    _usingHistory = userOptions.ai.useHistory;
    _key = '';
    _requestCount = 0;
    _safe = true;
    _temperature = userOptions.ai.defaultTemperature;
    _messages = [];
    _modelIndex = 0;
    _decoder = new TextDecoder();

    constructor() {
        super();

        if (fileExists(KEY_FILE_LOCATION)) this._key = Utils.readFile(KEY_FILE_LOCATION).trim();
        else this.emit('hasKey', false);

        // if (this._usingHistory) Utils.timeout(1000, () => this.loadHistory());
        if (this._usingHistory) this.loadHistory();
        else this._messages = this._assistantPrompt ? [...initMessages] : [];

        this.emit('initialized');
    }

    get modelName() { return CHAT_MODELS[this._modelIndex] }

    get keyPath() { return KEY_FILE_LOCATION }
    get historyPath() { return HISTORY_PATH }
    get key() { return this._key }
    set key(keyValue) {
        this._key = keyValue;
        Utils.writeFile(this._key, KEY_FILE_LOCATION)
            .then(this.emit('hasKey', true))
            .catch(err => print(err));
    }

    get cycleModels() { return this._cycleModels }
    set cycleModels(value) {
        this._cycleModels = value;
        if (!value) this._modelIndex = 0;
        else {
            this._modelIndex = (this._requestCount - (this._requestCount % ONE_CYCLE_COUNT)) % CHAT_MODELS.length;
        }
    }

    get useHistory() { return this._usingHistory; }
    set useHistory(value) {
        if (value && !this._usingHistory) this.loadHistory();
        this._usingHistory = value;
    }

    get safe() { return this._safe }
    set safe(value) { this._safe = value; }

    get temperature() { return this._temperature }
    set temperature(value) { this._temperature = value; }

    get messages() { return this._messages }
    get lastMessage() { return this._messages[this._messages.length - 1] }

    saveHistory() {
        Utils.writeFile(JSON.stringify(this._messages.map(msg => {
            let m = { role: msg.role, parts: msg.parts }; return m;
        })), HISTORY_PATH);
    }

    loadHistory() {
        this._messages = [];
        this.appendHistory();
        this._usingHistory = true;
    }

    appendHistory() {
        if (fileExists(HISTORY_PATH)) {
            const readfile = Utils.readFile(HISTORY_PATH);
            JSON.parse(readfile).forEach(element => {
                // this._messages.push(element);
                this.addMessage(element.role, element.parts[0].text);
            });
            // console.log(this._messages)
            // this._messages = this._messages.concat(JSON.parse(readfile));
            // for (let index = 0; index < this._messages.length; index++) {
            //     this.emit('newMsg', index);
            // }
        }
        else {
            this._messages = this._assistantPrompt ? [...initMessages] : []
            Utils.exec(`bash -c 'mkdir -p ${HISTORY_DIR} && touch ${HISTORY_PATH}'`)
        }
    }

    clear() {
        this._messages = this._assistantPrompt ? [...initMessages] : [];
        if (this._usingHistory) this.saveHistory();
        this.emit('clear');
    }

    get assistantPrompt() { return this._assistantPrompt; }
    set assistantPrompt(value) {
        this._assistantPrompt = value;
        if (value) this._messages = [...initMessages];
        else this._messages = [];
    }

    readResponse(stream, aiResponse) {
        stream.read_line_async(
            0, null,
            (stream, res) => {
                try {
                    const [bytes] = stream.read_line_finish(res);
                    const line = this._decoder.decode(bytes);
                    // console.log(line);
                    if (line == '[{') { // beginning of response
                        aiResponse._rawData += '{';
                        this.thinking = false;
                    }
                    else if (line == ',\u000d' || line == ']') { // end of stream pulse
                        aiResponse.parseSection();
                    }
                    else // Normal content
                        aiResponse._rawData += line;

                    this.readResponse(stream, aiResponse);
                } catch {
                    aiResponse.done = true;
                    if (this._usingHistory) this.saveHistory();
                    return;
                }
            });
    }

    addMessage(role, message) {
        this._messages.push(new GeminiMessage(role, message));
        this.emit('newMsg', this._messages.length - 1);
    }

    send(msg) {
        this._messages.push(new GeminiMessage('user', msg));
        this.emit('newMsg', this._messages.length - 1);
        const aiResponse = new GeminiMessage('model', 'thinking...', true, false)

        const body =
        {
            "contents": this._messages.map(msg => { let m = { role: msg.role, parts: msg.parts }; return m; }),
  //           "safetySettings": this._safe ? [] : [
		//  {
		//     "category": "HARM_CATEGORY_HARASSMENT",
		//     "threshold": "BLOCK_NONE"
		//   },
		//   {
		//     "category": "HARM_CATEGORY_HATE_SPEECH",
		//     "threshold": "BLOCK_NONE"
		//   },
		//   {
		//     "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
		//     "threshold": "BLOCK_NONE"
		//   },
		//   {
		//     "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
		//     "threshold": "BLOCK_NONE"
		//   },   
	 //    ],
  //           "generationConfig": {
  //               "temperature": this._temperature,
		// "topK": 1000,
		// "topP": 1,
		//
  //           },
            // "key": this._key,
            // "apiKey": this._key,
        };

        const session = new Soup.Session();
        const message = new Soup.Message({
            method: 'POST',
            uri: GLib.Uri.parse(replaceapidom(`https://generativelanguage.googleapis.com/v1/models/${this.modelName}:streamGenerateContent?key=${this._key}`), GLib.UriFlags.NONE),
        });
        message.request_headers.append('Content-Type', `application/json`);
        message.set_request_body_from_bytes('application/json', new GLib.Bytes(JSON.stringify(body)));

        session.send_async(message, GLib.DEFAULT_PRIORITY, null, (_, result) => {
            const stream = session.send_finish(result);
            this.readResponse(new Gio.DataInputStream({
                close_base_stream: true,
                base_stream: stream
            }), aiResponse);
        });
        this._messages.push(aiResponse);
        this.emit('newMsg', this._messages.length - 1);

        if (this._cycleModels) {
            this._requestCount++;
            if (this._cycleModels)
                this._modelIndex = (this._requestCount - (this._requestCount % ONE_CYCLE_COUNT)) % CHAT_MODELS.length;
        }
    }
}

export default new GeminiService();

